"""Runner generator for captain-hook."""

import shlex
import stat
from pathlib import Path

from . import config, scanner

# Template for generated bash runners
RUNNER_TEMPLATE = '''#!/usr/bin/env bash
# Auto-generated by captain-hook - do not edit manually
# Event: {event}
# Regenerate with: captain-hook toggle

set -euo pipefail

INPUT=$(cat)
HOOKS_DIR="{hooks_dir}"
VENV_PYTHON="{venv_python}"
{debug_setup}
# Check for project override runner
PROJECT_RUNNER=".claude/captain-hook/runners/{event}.sh"
if [[ -f "$PROJECT_RUNNER" ]]; then
    {debug_project_runner}echo "$INPUT" | "$PROJECT_RUNNER"
    exit $?
fi

{hook_calls}
{debug_complete}exit 0
'''

# Template for project-specific runners (no project override check)
PROJECT_RUNNER_TEMPLATE = '''#!/usr/bin/env bash
# Auto-generated by captain-hook - do not edit manually
# Event: {event}
# Project: {project_dir}
# Regenerate with: captain-hook toggle

set -euo pipefail

INPUT=$(cat)
HOOKS_DIR="{hooks_dir}"
VENV_PYTHON="{venv_python}"
{debug_setup}
{hook_calls}
{debug_complete}exit 0
'''


def _get_debug_snippets(event: str, is_project: bool = False) -> dict[str, str]:
    """Get debug code snippets if debug is enabled."""
    cfg = config.load_config()
    if not cfg.get("debug", False):
        return {
            "debug_setup": "",
            "debug_project_runner": "",
            "debug_complete": "",
        }

    log_path = config.get_log_path()
    event_label = f"{event} (project)" if is_project else event

    return {
        "debug_setup": f'''DEBUG_LOG="{log_path}"
log_debug() {{ echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$DEBUG_LOG"; }}
log_debug "EVENT: {event_label}"
log_debug "INPUT: $INPUT"
''',
        "debug_project_runner": f'log_debug "Using project runner: $PROJECT_RUNNER"\n    ',
        "debug_complete": f'log_debug "EVENT COMPLETE: {event}"\n',
    }


def get_interpreter_call(hook: scanner.HookInfo, venv_python: str) -> str:
    """Get the command to run a hook."""
    # Use shlex.quote to prevent command injection via malicious filenames
    safe_path = shlex.quote(str(hook.path))
    if hook.is_stdout:
        # Stdout hooks just output their content (no stdin processing)
        return f'cat {safe_path}'
    elif hook.extension == ".py":
        return f'"$VENV_PYTHON" {safe_path}'
    elif hook.extension == ".js":
        return f'node {safe_path}'
    elif hook.extension == ".sh":
        return f'bash {safe_path}'
    elif hook.extension == ".ts":
        return f'bun run {safe_path}'
    else:
        return safe_path


def generate_runner(
    event: str,
    enabled_hooks: list[str],
    hooks_dir: Path | None = None,
    runners_dir: Path | None = None,
    is_project: bool = False,
    project_dir: Path | None = None,
) -> Path | None:
    """Generate a bash runner for an event.

    Args:
        event: The event name
        enabled_hooks: List of enabled hook names
        hooks_dir: Path to hooks directory
        runners_dir: Path to runners directory
        is_project: Whether this is a project-specific runner
        project_dir: Project directory (for project runners)

    Returns:
        Path to generated runner, or None if no hooks enabled.
    """
    if hooks_dir is None:
        hooks_dir = config.get_hooks_dir()
    if runners_dir is None:
        runners_dir = config.get_runners_dir() if not is_project else config.get_project_runners_dir(project_dir)

    # Scan for hooks
    all_hooks = scanner.scan_hooks(hooks_dir)
    event_hooks = all_hooks.get(event, [])

    # Filter to enabled hooks (exclude native prompt hooks - they're registered directly)
    hooks_to_run = [
        h for h in event_hooks
        if h.name in enabled_hooks and not h.is_native_prompt
    ]

    if not hooks_to_run:
        # No hooks to run - create empty runner that just exits
        runner_path = runners_dir / f"{event}.sh"
        runners_dir.mkdir(parents=True, exist_ok=True)

        content = f'''#!/usr/bin/env bash
# Auto-generated by captain-hook - no hooks enabled
# Event: {event}
exit 0
'''
        runner_path.write_text(content)
        _make_executable(runner_path)
        return runner_path

    # Generate hook calls
    venv_python = str(config.get_venv_python())
    cfg = config.load_config()
    debug_enabled = cfg.get("debug", False)

    hook_calls = []
    for hook in hooks_to_run:
        call = get_interpreter_call(hook, venv_python)
        if hook.is_stdout:
            # Stdout hooks just output their content (no stdin)
            if debug_enabled:
                hook_calls.append(f'log_debug "HOOK: {hook.name} (stdout)"')
                hook_calls.append(f'{call}')
                hook_calls.append(f'log_debug "HOOK OK: {hook.name}"')
            else:
                hook_calls.append(f'{call}')
        else:
            # Command hooks receive JSON input via stdin
            if debug_enabled:
                hook_calls.append(f'log_debug "HOOK: {hook.name}"')
                hook_calls.append(f'echo "$INPUT" | {call}')
                hook_calls.append(f'HOOK_EXIT=$?')
                hook_calls.append(f'if [[ $HOOK_EXIT -ne 0 ]]; then log_debug "HOOK FAILED: {hook.name} (exit $HOOK_EXIT)"; exit $HOOK_EXIT; fi')
                hook_calls.append(f'log_debug "HOOK OK: {hook.name}"')
            else:
                hook_calls.append(f'echo "$INPUT" | {call} || exit $?')

    hook_calls_str = "\n".join(hook_calls)

    # Get debug snippets
    debug = _get_debug_snippets(event, is_project=is_project)

    # Generate runner content
    if is_project:
        content = PROJECT_RUNNER_TEMPLATE.format(
            event=event,
            project_dir=str(project_dir) if project_dir else "unknown",
            hooks_dir=str(hooks_dir / event),
            venv_python=venv_python,
            hook_calls=hook_calls_str,
            **debug,
        )
    else:
        content = RUNNER_TEMPLATE.format(
            event=event,
            hooks_dir=str(hooks_dir / event),
            venv_python=venv_python,
            hook_calls=hook_calls_str,
            **debug,
        )

    # Write runner
    runners_dir.mkdir(parents=True, exist_ok=True)
    runner_path = runners_dir / f"{event}.sh"
    runner_path.write_text(content)
    _make_executable(runner_path)

    return runner_path


def generate_all_runners(scope: str = "global", project_dir: Path | None = None) -> list[Path]:
    """Generate runners for all events.

    Args:
        scope: 'global' or 'project'
        project_dir: Project directory for project scope

    Returns:
        List of generated runner paths.
    """
    runners = []

    for event in config.EVENTS:
        enabled = config.get_enabled_hooks(event, project_dir if scope == "project" else None)

        if scope == "project":
            runner = generate_runner(
                event=event,
                enabled_hooks=enabled,
                is_project=True,
                project_dir=project_dir,
            )
        else:
            runner = generate_runner(
                event=event,
                enabled_hooks=enabled,
            )

        if runner:
            runners.append(runner)

    return runners


def _make_executable(path: Path) -> None:
    """Make a file executable."""
    try:
        current = path.stat().st_mode
        path.chmod(current | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    except (OSError, PermissionError):
        # On Windows or read-only systems, this may fail
        pass


def get_runner_path(event: str) -> Path:
    """Get the path to a global runner."""
    return config.get_runners_dir() / f"{event}.sh"


def get_project_runner_path(event: str, project_dir: Path | None = None) -> Path:
    """Get the path to a project runner."""
    return config.get_project_runners_dir(project_dir) / f"{event}.sh"
