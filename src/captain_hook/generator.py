"""Runner generator for captain-hook."""

from __future__ import annotations

import os
import shlex
import shutil
import stat
import tempfile
from pathlib import Path

from . import config, scanner
from .types import Scope


def _get_interpreter_path(interpreter: str) -> str:
    """Get absolute path for an interpreter, falling back to name if not found.

    Security: Using absolute paths prevents PATH manipulation attacks.
    """
    path = shutil.which(interpreter)
    return path if path else interpreter


def _atomic_write_executable(path: Path, content: str) -> None:
    """Write content to file atomically with executable permissions.

    Security: Prevents TOCTOU race conditions by writing to a temp file
    with correct permissions, then atomically renaming.
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    # Create temp file in same directory for atomic rename
    fd, tmp_path = tempfile.mkstemp(dir=path.parent, suffix=".tmp")
    try:
        # Write content and set permissions atomically
        os.write(fd, content.encode("utf-8"))
        os.fchmod(fd, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)
        os.close(fd)
        # Atomic rename
        os.rename(tmp_path, path)
    except Exception:
        os.close(fd)
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        raise


# Template for generated bash runners
RUNNER_TEMPLATE = """#!/usr/bin/env bash
# Auto-generated by captain-hook - do not edit manually
# Event: {event}
# Regenerate with: captain-hook toggle

set -euo pipefail

INPUT=$(cat)
HOOKS_DIR="{hooks_dir}"
VENV_PYTHON="{venv_python}"
VENV_BIN="$(dirname "$VENV_PYTHON")"
export PATH="$VENV_BIN:$PATH"
{env_exports}{debug_setup}
# Check for project override runner
PROJECT_RUNNER=".claude/captain-hook/runners/{event}.sh"
if [[ -f "$PROJECT_RUNNER" ]]; then
    {debug_project_runner}echo "$INPUT" | "$PROJECT_RUNNER"
    exit $?
fi

{hook_calls}
{debug_complete}exit 0
"""

# Template for project-specific runners (no project override check)
PROJECT_RUNNER_TEMPLATE = """#!/usr/bin/env bash
# Auto-generated by captain-hook - do not edit manually
# Event: {event}
# Project: {project_dir}
# Regenerate with: captain-hook toggle

set -euo pipefail

INPUT=$(cat)
HOOKS_DIR="{hooks_dir}"
VENV_PYTHON="{venv_python}"
VENV_BIN="$(dirname "$VENV_PYTHON")"
export PATH="$VENV_BIN:$PATH"
{env_exports}{debug_setup}
{hook_calls}
{debug_complete}exit 0
"""


def _get_env_exports() -> str:
    """Generate export statements for env vars."""
    # Get all env vars from scripts (with defaults)
    script_env_vars = scanner.get_all_env_vars()
    if not script_env_vars:
        return ""

    # Get configured values
    cfg = config.load_config()
    env_config = cfg.get("env", {})

    # Build export statements
    exports = []
    for var_name, default_value in sorted(script_env_vars.items()):
        # Use configured value or default
        value = env_config.get(var_name, default_value)
        # Escape for bash
        safe_value = shlex.quote(value)
        exports.append(f"export {var_name}={safe_value}")

    if exports:
        return "\n".join(exports) + "\n"
    return ""


def _get_debug_snippets(event: str, is_project: bool = False) -> dict[str, str]:
    """Get debug code snippets if debug is enabled."""
    cfg = config.load_config()
    if not cfg.get("debug", False):
        return {
            "debug_setup": "",
            "debug_project_runner": "",
            "debug_complete": "",
        }

    log_path = config.get_log_path()
    event_label = f"{event} (project)" if is_project else event

    return {
        "debug_setup": f'''DEBUG_LOG="{log_path}"
log_debug() {{ echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$DEBUG_LOG"; }}
# Extract cwd and session from input for readable logging
if command -v jq &>/dev/null; then
  _CWD=$(echo "$INPUT" | jq -r '.cwd // "unknown"' 2>/dev/null)
  _SESSION=$(echo "$INPUT" | jq -r '.session_id // "unknown"' 2>/dev/null | cut -c1-8)
else
  _CWD="(jq not installed)"
  _SESSION="?"
fi
log_debug "EVENT: {event_label} | cwd=$_CWD | session=$_SESSION"
''',
        "debug_project_runner": 'log_debug "Using project runner: $PROJECT_RUNNER"\n    ',
        "debug_complete": f'log_debug "EVENT COMPLETE: {event}"\n',
    }


def get_interpreter_call(hook: scanner.HookInfo, venv_python: str) -> str:
    """Get the command to run a hook.

    Security: Uses absolute paths for interpreters to prevent PATH manipulation.
    """
    # Use shlex.quote to prevent command injection via malicious filenames
    safe_path = shlex.quote(str(hook.path))
    if hook.is_stdout:
        # Stdout hooks just output their content (no stdin processing)
        cat_path = _get_interpreter_path("cat")
        return f"{cat_path} {safe_path}"
    elif hook.extension == ".py":
        return f'"$VENV_PYTHON" {safe_path}'
    elif hook.extension == ".js":
        node_path = _get_interpreter_path("node")
        return f"{node_path} {safe_path}"
    elif hook.extension == ".sh":
        bash_path = _get_interpreter_path("bash")
        return f"{bash_path} {safe_path}"
    elif hook.extension == ".ts":
        bun_path = _get_interpreter_path("bun")
        return f"{bun_path} run {safe_path}"
    else:
        return safe_path


def generate_runner(
    event: str,
    enabled_hooks: list[str],
    hooks_dir: Path | None = None,
    runners_dir: Path | None = None,
    is_project: bool = False,
    project_dir: Path | None = None,
) -> Path | None:
    """Generate a bash runner for an event.

    Args:
        event: The event name
        enabled_hooks: List of enabled hook names
        hooks_dir: Path to hooks directory
        runners_dir: Path to runners directory
        is_project: Whether this is a project-specific runner
        project_dir: Project directory (for project runners)

    Returns:
        Path to generated runner, or None if no hooks enabled.
    """
    if hooks_dir is None:
        hooks_dir = config.get_hooks_dir()
    if runners_dir is None:
        runners_dir = (
            config.get_runners_dir()
            if not is_project
            else config.get_project_runners_dir(project_dir)
        )

    # Scan for hooks
    all_hooks = scanner.scan_hooks(hooks_dir)
    event_hooks = all_hooks.get(event, [])

    # Filter to enabled hooks (exclude native prompt hooks - they're registered directly)
    hooks_to_run = [h for h in event_hooks if h.name in enabled_hooks and not h.is_native_prompt]

    if not hooks_to_run:
        # No hooks to run - create empty runner that just exits
        runner_path = runners_dir / f"{event}.sh"
        content = f"""#!/usr/bin/env bash
# Auto-generated by captain-hook - no hooks enabled
# Event: {event}
exit 0
"""
        # Security: atomic write to prevent TOCTOU race
        _atomic_write_executable(runner_path, content)
        return runner_path

    # Generate hook calls
    venv_python = str(config.get_venv_python())
    cfg = config.load_config()
    debug_enabled = cfg.get("debug", False)

    hook_calls = []
    for hook in hooks_to_run:
        call = get_interpreter_call(hook, venv_python)
        hook_path = shlex.quote(str(hook.path))

        if hook.is_stdout:
            # Stdout hooks - skip if file was deleted
            if debug_enabled:
                hook_calls.append(f"if [[ -f {hook_path} ]]; then")
                hook_calls.append(f'  log_debug "HOOK: {hook.name} (stdout)"')
                hook_calls.append(f"  {call}")
                hook_calls.append(f'  log_debug "HOOK OK: {hook.name}"')
                hook_calls.append("fi")
            else:
                hook_calls.append(f"[[ -f {hook_path} ]] && {call}")
        else:
            # Command hooks - skip if file was deleted
            if debug_enabled:
                hook_calls.append(f"if [[ -f {hook_path} ]]; then")
                hook_calls.append(f'  log_debug "HOOK: {hook.name}"')
                hook_calls.append(f'  echo "$INPUT" | {call}')
                hook_calls.append("  HOOK_EXIT=$?")
                hook_calls.append(
                    f'  if [[ $HOOK_EXIT -ne 0 ]]; then log_debug "HOOK FAILED: {hook.name} (exit $HOOK_EXIT)"; exit $HOOK_EXIT; fi'
                )
                hook_calls.append(f'  log_debug "HOOK OK: {hook.name}"')
                hook_calls.append("fi")
            else:
                hook_calls.append(
                    f'[[ -f {hook_path} ]] && {{ echo "$INPUT" | {call} || exit $?; }}'
                )

    hook_calls_str = "\n".join(hook_calls)

    # Get debug snippets and env exports
    debug = _get_debug_snippets(event, is_project=is_project)
    env_exports = _get_env_exports()

    # Generate runner content
    if is_project:
        content = PROJECT_RUNNER_TEMPLATE.format(
            event=event,
            project_dir=str(project_dir) if project_dir else "unknown",
            hooks_dir=str(hooks_dir / event),
            venv_python=venv_python,
            hook_calls=hook_calls_str,
            env_exports=env_exports,
            **debug,
        )
    else:
        content = RUNNER_TEMPLATE.format(
            event=event,
            hooks_dir=str(hooks_dir / event),
            venv_python=venv_python,
            hook_calls=hook_calls_str,
            env_exports=env_exports,
            **debug,
        )

    # Write runner with atomic operation
    runner_path = runners_dir / f"{event}.sh"
    # Security: atomic write to prevent TOCTOU race
    _atomic_write_executable(runner_path, content)

    return runner_path


def generate_all_runners(
    scope: Scope | str = Scope.USER, project_dir: Path | None = None
) -> list[Path]:
    """Generate runners for all events.

    Args:
        scope: USER for global settings, PROJECT for project-specific.
               Accepts Scope enum or string ("user", "global", "project").
        project_dir: Project directory for PROJECT scope.

    Returns:
        List of generated runner paths.
    """
    # Normalize string to Scope enum (handles legacy "global" -> USER mapping)
    if isinstance(scope, str):
        scope = Scope.from_string(scope)

    runners = []

    for event in config.EVENTS:
        enabled = config.get_enabled_hooks(event, project_dir if scope == Scope.PROJECT else None)

        if scope == Scope.PROJECT:
            runner = generate_runner(
                event=event,
                enabled_hooks=enabled,
                is_project=True,
                project_dir=project_dir,
            )
        else:
            runner = generate_runner(
                event=event,
                enabled_hooks=enabled,
            )

        if runner:
            runners.append(runner)

    return runners


def _make_executable(path: Path) -> None:
    """Make a file executable."""
    try:
        current = path.stat().st_mode
        path.chmod(current | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    except (OSError, PermissionError):
        # On Windows or read-only systems, this may fail
        pass


def get_runner_path(event: str) -> Path:
    """Get the path to a global runner."""
    return config.get_runners_dir() / f"{event}.sh"


def get_project_runner_path(event: str, project_dir: Path | None = None) -> Path:
    """Get the path to a project runner."""
    return config.get_project_runners_dir(project_dir) / f"{event}.sh"
